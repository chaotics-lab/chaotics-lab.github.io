{
  "title": "8-Bit Calculator (FPGA)",
  "date": "2021-10-03",
  "titleColor": "#FFFFFF",
  "description": "An 8-bit signed calculator capable of performing basic operations on FPGA. Controlable with a remote.",
  "imageUrl": "/img/FPGA",
  "logoUrl": "/img/FPGA/logo.png",
  "githubUrl": "https://github.com/Loxed/vhdl-calc",
  "themeColor": "#18395A",
  "logoBackgroundColor": "#FFFFFF",
  "category": [
    "embedded-systems",
    "sp"
  ],
  "tags": [
    "DE10-Lite",
    "VHDL",
    "FPGA",
    "IR NEC Protocol",
    "FSM"
  ],
  "status": "completed",
  "id": "8-bit-calculator-(fpga)",
  "markdown": "# FPGA-Based Calculator in VHDL\n## Overview\n\nA 4-bit calculator implemented on an Intel DE10-Lite FPGA using VHDL, featuring infrared remote control input, signed/unsigned arithmetic operations, and multi-modal output (7-segment displays, LEDs, buzzer). The project demonstrates hardware description language proficiency, digital logic design, and external component integration through GPIO interfaces.\n\n**Key Features:**\n- Infrared input decoding (NEC protocol)\n- Addition and multiplication (signed/unsigned modes)\n- Internal FPGA operations and external 74LS283 CLA adder integration\n- Multi-modal output: 7-segment displays, binary LED indicators, audible buzzer feedback\n- Overflow detection and mode indicators\n\n**Tech Stack:** VHDL, Intel Quartus, DE10-Lite FPGA (MAX 10), 74LS283 4-bit CLA adder, IR receiver (Carmp3 remote)\n\n## Technical Approach\n\n### Input Module (IR Reception)\n- **NEC Protocol Decoding:** Implemented state machine to decode infrared signals following NEC timing specifications (9ms lead pulse, 562μs/1.675ms bit encoding)\n- **Mealy Machine:** Three-state FSM manages operand A, operator, and operand B input with input validation\n- **Signed Number Handling:** MSB-based sign representation with custom two's complement logic for negative operands (range: -7 to +7 in signed mode)\n- **Hardware:** IR receiver connected to GPIO pins, reading hexadecimal commands mapped to calculator buttons\n\n### Computation Module\n- **Dual Arithmetic Modes:**\n  - **Unsigned:** 4-bit operands, 8-bit intermediate results, overflow detection for results >15\n  - **Signed:** MSB reserved for sign, 3-bit magnitude, custom sign handling without standard two's complement\n- **Internal Operations:** Direct VHDL arithmetic using `unsigned` type conversions (concat \"0000\" to 4-bit operands → 8-bit operations)\n- **External Operations:** 74LS283 CLA adder integration via GPIO (8 output pins for operands, 5 input pins for result + carry)\n- **Signed Addition Algorithm:**\n  1. Compute two's complement for negative operands\n  2. Perform unsigned addition via CLA\n  3. Determine result sign via operand sign analysis and carry bit\n  4. Apply two's complement to negative results\n- **Signed Multiplication:** XOR gate logic for sign determination (MSB(A) XOR MSB(B)), 3-bit magnitude multiplication, result concatenation\n\n### Output Modules\n- **7-Segment Display:** Six displays showing operands A, B, and result (switches to three displays for negative results to include sign)\n- **Binary LED Indicators:** Four yellow LEDs for 4-bit result, one red LED for overflow\n- **Mode Indicators:** Three onboard LEDs for operation type (add/multiply), signed mode, and external CLA mode\n- **Audible Feedback:** Buzzer generates frequency-modulated beeps (800Hz positive, 200Hz negative) counting result value using 10MHz clock dividers\n\n### Architecture\n- **Top-Level Moore Machine:** State-based result routing from computation modules to display/sound modules based on user-selected modes\n- **Modular Design:** Separate entities for IR reception, signed/unsigned internal operations, signed/unsigned external operations, display, and sound\n- **Clock Management:** 10MHz for buzzer timing, 50MHz for IR decoding\n\n## Challenges & Solutions\n\n### Challenge 1: Signed Arithmetic with External CLA\n**Problem:** 74LS283 performs only unsigned 4-bit addition; signed operations require two's complement handling and sign determination logic.\n\n**Solution:**\n- Pre-compute two's complement in FPGA before sending to CLA\n- Implement sign prediction: if operands have same sign, result sign matches operands; if different signs, carry bit determines sign\n- Post-process CLA result with conditional two's complement based on predicted sign\n- Overflow detection: verify 4th bit is zero when operands share sign\n\n### Challenge 2: NEC Protocol Timing Constraints\n**Problem:** Accurate bit detection requires precise timing analysis of 562μs pulses at 50MHz clock (28,000 cycles per pulse).\n\n**Solution:**\n- Counter-based state machine with timing thresholds: 1.125ms for '0' bits, 2.25ms for '1' bits\n- Extract 8-bit command from 32-bit data register (bits 16-23)\n- Input validation: state machine accepts only valid commands in appropriate states (digits in operand states, operators in operator state)\n\n### Challenge 3: Multi-Bit Result Representation on 4-Bit Display\n**Problem:** Multiplication can yield 8-bit results (max: 15×15=225 unsigned, 7×7=49 signed), but only 4 bits available.\n\n**Solution:**\n- Store intermediate results in 8-bit unsigned signals\n- Truncate to 4 LSBs for final display\n- Activate overflow LED when result exceeds 4-bit capacity (bit 4+ non-zero)\n- Binary LED display preserves full 4-bit information alongside truncated decimal display\n\n### Challenge 4: Buzzer Frequency Generation\n**Problem:** Generate distinct audible feedback (800Hz positive, 200Hz negative) from 10MHz clock while beeping result count.\n\n**Solution:**\n- **Counter 1:** Divides clock to target frequency (6,250 cycles for 800Hz, 25,000 for 200Hz)\n- **Counter 2:** Controls beep timing (200ms on, 600ms off = 0.8s period)\n- **Decounter:** Decrements on each beep cycle until reaching zero, initialized to absolute value of result\n- Sign-based frequency selection via multiplexer switching counter thresholds\n\n## Results & Impact\n\n**Functional Achievements:**\n- ✅ Full NEC protocol decoding with 21-button remote support\n- ✅ 8 operational modes: signed/unsigned × internal/external × add/multiply\n- ✅ Accurate signed arithmetic with custom two's complement implementation\n- ✅ External CLA integration demonstrating FPGA-to-IC interfacing\n- ✅ Multi-sensory output (visual + audible) with comprehensive mode indication\n\n**Learning Outcomes:**\n- **Hardware Description Languages:** Advanced VHDL constructs (FSMs, type conversions, concurrent logic)\n- **Digital Logic Design:** Adder architectures (ripple-carry vs. carry-lookahead), two's complement arithmetic, overflow detection\n- **Protocol Implementation:** Timing-critical signal decoding, state machine design patterns\n- **FPGA Development Workflow:** RTL synthesis, testbench validation, constraint files, GPIO mapping\n- **Hardware-Software Co-Design:** Interfacing VHDL logic with external ICs via bidirectional GPIO\n\n**Performance Metrics:**\n- Clock frequencies: 50MHz (IR), 10MHz (buzzer)\n- Latency: <1ms for IR decode → computation → display pipeline\n- Resource utilization: Optimized for MAX 10 FPGA logic elements and GPIO constraints\n\n**Validated Through:**\n- Comprehensive testbenches with timing diagrams (see chronograms in report)\n- Physical testing: 37 images documenting operations across all modes\n- Edge case testing: overflow conditions, negative operands, external CLA boundary cases\n\n## References\n\n- **Project Repository:** [GitHub - Loxed/vhdl-calc](https://github.com/Loxed/vhdl-calc)\n- **FPGA Board:** [DE10-Lite User Manual (Intel Terasic)](https://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&No=1021)\n- **NEC Protocol:** [Circuit Valley - IR Protocol Implementation](https://www.circuitvalley.com)\n- **74LS283 Datasheet:** [4-Bit CLA Adder (mil.ufl.edu)](http://mil.ufl.edu/)\n- **VHDL Reference:** [VHDLANDE.com Standards Documentation](http://vhdlande.com)\n- **IEEE VHDL Standard:** IEEE Std 1076-2008\n\n---\n\n**Team:** Léopold Rombaut, Tristan Querton, Victor Ratti, Matia Cilly  \n**Institution:** ECE Paris, Semester 3 Electronics Project  \n**Completion:** October 2021"
  }
