{
  "title": "Le Saboteur (French Board Game)",
  "date": "2021-02-10",
  "titleColor": "#FFFFFF",
  "description": "A video game adaptation of 'Le Saboteur', a French board game, with a wild-west pixel art theme.",
  "imageUrl": "/img/saboteur",
  "logoUrl": "/img/saboteur/logo.png",
  "themeColor": "#ffe7a5",
  "logoBackgroundColor": "transparent",
  "githubUrl": "https://github.com/Loxed/le-saboteur",
  "category": [
    "game"
  ],
  "tags": [
    "C",
    "Allegro 4",
    "Pixel Art"
  ],
  "type": "Academic Project",
  "id": "le-saboteur-(french-board-game)",
  "markdown": "## Overview\n\nA **digital adaptation of the classic French social deduction board game** *Saboteur*, reimagined with a wild-west pixel art theme. Built in C with Allegro 4, this project transforms the card-based mining game into an interactive multiplayer experience featuring hidden roles, strategic path-building, and sabotage mechanics — demonstrating low-level game programming and custom graphics pipeline implementation.\n\n**Game Concept:** Players take on roles as gold miners or saboteurs, collaboratively building tunnel paths toward treasure while hidden saboteurs secretly undermine the group's efforts. The game combines cooperation, deduction, and bluffing in a tense race to uncover gold or prevent its discovery.\n\n## Technical Approach\n\n### Architecture\n\n**Tech Stack:**\n- **Language:** C (procedural programming with manual memory management)\n- **Graphics Library:** Allegro 4 (2D rendering, sprite handling, input management)\n- **Art Style:** Wild-west themed pixel art (custom sprites replacing medieval mining theme)\n- **Design:** Turn-based multiplayer with hidden information mechanics\n\n### Core Systems\n\n**1. Game Logic Engine**\n\n```c\n// Core game structures\ntypedef enum {\n    ROLE_MINER,\n    ROLE_SABOTEUR\n} PlayerRole;\n\ntypedef struct {\n    int player_id;\n    PlayerRole role;\n    Card hand[MAX_HAND_SIZE];\n    bool is_blocked;  // Tool card effects\n    int gold_collected;\n} Player;\n\ntypedef struct {\n    CardType type;  // PATH, ACTION, GOAL\n    PathShape shape;  // Straight, corner, T-junction, etc.\n    bool has_gold;   // For goal cards\n} Card;\n\ntypedef struct {\n    Card grid[GRID_WIDTH][GRID_HEIGHT];\n    Player players[MAX_PLAYERS];\n    int current_player;\n    GamePhase phase;  // SETUP, PLAYING, SCORING\n} GameState;\n```\n\n**Game Flow:**\n1. **Role Assignment:** Randomly distribute miner/saboteur roles (hidden from other players)\n2. **Path Building:** Players take turns placing tunnel cards to connect start → goal\n3. **Sabotage:** Saboteurs place dead-end paths or block opponents with action cards\n4. **Discovery:** When path reaches goal card, reveal if it contains gold\n5. **Scoring:** Miners share gold if found; saboteurs win if time runs out\n\n**2. Path Validation System**\n\n**Challenge:** Ensure placed cards connect properly (no floating tunnels, valid connections).\n\n```c\nbool validate_card_placement(GameState* state, int x, int y, Card* card) {\n    // Check adjacency rules\n    if (x > 0) {\n        Card* left = &state->grid[x-1][y];\n        if (!connections_match(card->shape, WEST, left->shape, EAST))\n            return false;\n    }\n    \n    // Check for existing card\n    if (state->grid[x][y].type != CARD_EMPTY)\n        return false;\n    \n    // Check distance from start (prevent shortcuts)\n    if (manhattan_distance(x, y, START_X, START_Y) > MAX_DISTANCE)\n        return false;\n    \n    return true;\n}\n```\n\n**Path Connection Logic:**\n- Cards have 4 directional connectors (N/S/E/W)\n- Adjacent cards must have matching open/closed sides\n- Dead-end cards (saboteur strategy) have intentional mismatches\n\n**3. Hidden Role Mechanics**\n\n**Saboteur Gameplay:**\n- Identity hidden from other players (no HUD indicator)\n- Subtle sabotage: Place valid-looking paths that lead nowhere\n- Action cards: Block miners' tools (pickaxe, lantern, cart)\n- Goal obfuscation: Multiple goal cards (only 1 has gold)\n\n**Deduction Elements:**\n- Players infer roles from card play patterns\n- Voting/accusation system (optional rule)\n- Tension between cooperation and suspicion\n\n**4. Wild West Thematic Adaptation**\n\n**Visual Design:**\n- **Original Theme:** Medieval dwarven miners in mountain tunnels\n- **Reimagined:** Wild-west gold rush prospectors in desert mines\n- **Sprite Assets:**\n  - Player avatars: Cowboys, sheriffs, outlaws\n  - Cards: Wooden planks, minecart tracks, TNT (sabotage)\n  - Background: Sepia-toned desert landscape\n  - UI: Aged parchment, wanted posters aesthetic\n\n**Pixel Art Pipeline:**\n- Custom sprites designed at 32×32 or 64×64 resolution\n- Limited color palette (8-16 colors per sprite for retro feel)\n- Frame-by-frame animation for card placement effects\n\n**5. Multiplayer System**\n\n**Local Multiplayer:**\n- Hot-seat play (players take turns at same computer)\n- Hidden role screen: Each player privately views their role at game start\n- Hand management: Cards hidden when not current player's turn\n\n**Turn Structure:**\n```c\nvoid process_turn(GameState* state) {\n    Player* current = &state->players[state->current_player];\n    \n    // 1. Display current player's hand\n    render_hand(current->hand);\n    \n    // 2. Player chooses action\n    Action action = get_player_input();\n    \n    // 3. Execute action (place card, use tool, pass)\n    execute_action(state, action);\n    \n    // 4. Draw new card\n    draw_card(&current->hand);\n    \n    // 5. Check win conditions\n    if (check_goal_reached(state)) {\n        state->phase = PHASE_SCORING;\n    }\n    \n    // 6. Next player\n    state->current_player = (state->current_player + 1) % state->num_players;\n}\n```\n\n**6. Allegro 4 Rendering Pipeline**\n\n**Graphics Implementation:**\n```c\nvoid render_game(GameState* state, BITMAP* buffer) {\n    // Double buffering for flicker-free rendering\n    clear_to_color(buffer, COLOR_BACKGROUND);\n    \n    // Draw grid\n    for (int x = 0; x < GRID_WIDTH; x++) {\n        for (int y = 0; y < GRID_HEIGHT; y++) {\n            if (state->grid[x][y].type != CARD_EMPTY) {\n                draw_sprite(buffer, card_sprites[state->grid[x][y].shape], \n                           x * TILE_SIZE, y * TILE_SIZE);\n            }\n        }\n    }\n    \n    // Draw current player's hand\n    render_hand(buffer, &state->players[state->current_player]);\n    \n    // Draw UI (turn indicator, score)\n    render_ui(buffer, state);\n    \n    // Flip buffer to screen\n    blit(buffer, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);\n}\n```\n\n**Event Handling:**\n- Mouse input for card selection and placement\n- Keyboard shortcuts for common actions\n- Custom cursor (pickaxe sprite) for thematic consistency\n\n## Challenges & Solutions\n\n| Challenge | Solution |\n|-----------|----------|\n| **Hidden information** in local multiplayer | \"Close your eyes\" screen transitions; timed reveal of role cards |\n| **Path validation complexity** | Adjacency matrix for connection rules; recursive flood-fill to detect dead ends |\n| **Manual memory management** in C | Careful allocation/deallocation; valgrind testing for leaks |\n| **Sprite loading** (100+ cards/assets) | Asset manager with hash map for O(1) lookup; lazy loading |\n| **Turn order clarity** | Animated player token; sound effects for turn changes |\n| **Saboteur balancing** | Playtested ratio of miners:saboteurs (tested 3:1, 4:2, 5:2 ratios) |\n| **Allegro 4 portability** | Conditional compilation for Windows/Linux; makefile with platform detection |\n\n## Results / Impact\n\n**Gameplay Features:**\n- ✅ **Full ruleset** implementation (path cards, action cards, goal cards)\n- ✅ **3-10 player support** (scalable player count)\n- ✅ **Wild-west theming** with custom pixel art assets\n- ✅ **Strategic depth:** Deduction, bluffing, path optimization\n- ✅ **Replayability:** Randomized roles and goal placement\n\n**Technical Achievements:**\n- Demonstrated **low-level C programming** (pointers, structs, manual memory)\n- Applied **2D game development** techniques (sprite rendering, collision detection)\n- Designed **finite state machine** for game phases and turn logic\n- Created **modular architecture** (separate files for rendering, logic, input)\n- Gained proficiency with **Allegro 4 API** (graphics primitives, event handling)\n\n**Artistic Contributions:**\n- **Custom pixel art:** 50+ card sprites, character avatars, UI elements\n- **Thematic adaptation:** Successfully translated medieval → wild-west aesthetic\n- **Cohesive style guide:** Consistent color palette and sprite resolution\n\n**Learning Outcomes:**\n- **Game Design:** Social deduction mechanics, hidden information, player psychology\n- **C Programming:** Procedural design, memory management, debugging techniques\n- **Graphics Programming:** Double buffering, sprite sheets, animation loops\n- **Project Management:** Solo development from concept to playable prototype\n\n## References\n\n- [GitHub Repository](https://github.com/Loxed/le-saboteur)\n- **Original Game:** *Saboteur* by Frederic Moyersoen (2004) — card-based mining game with traitor mechanic\n- **Graphics Library:** [Allegro 4 Documentation](https://liballeg.org/)\n- **Similar Games:** The Resistance, Avalon (social deduction genre)\n\n**Technologies:** C, Allegro 4, Pixel Art, Game Design, State Machines, 2D Graphics, Procedural Programming, Memory Management"
}