{
  "title": "ECECOPTER (Remote Controlled Drone)",
  "date": "2024-02-15",
  "titleColor": "#FFFFFF",
  "description": "Designed and built a fully functional drone and remote system, including PCBs, sensors, and communication protocols.",
  "imageUrl": "/img/ececopter",
  "logoUrl": "/img/ececopter/logo.png",
  "themeColor": "#00848c",
  "logoBackgroundColor": "#FFFFFF",
  "category": [
    "embedded-systems",
    "robotics"
  ],
  "demoUrl": "https://www.linkedin.com/posts/leopold-rombaut_ececopter-embeddedsystems-dronetechnology-activity-7134805600864989185-h-t2",
  "tags": [
    "ATmega328p",
    "KiCad",
    "Fusion360",
    "ToF",
    "IMU"
  ],
  "type": "Academic Project",
  "id": "ececopter-(remote-controlled-drone)",
  "markdown": "## Overview\n\nDesigned and built a **fully functional quadcopter drone system from scratch**, including custom PCB design, sensor integration, and wireless remote control. This comprehensive embedded systems project spans electrical engineering, mechanical design, firmware development, and flight control algorithms — demonstrating end-to-end product development from schematic to flight-tested hardware.\n\n**Project Scope:** Complete drone ecosystem including flight controller PCB, IMU-based stabilization, Time-of-Flight (ToF) altitude sensing, custom remote controller with joystick interface, and bidirectional wireless communication.\n\n## Technical Approach\n\n### System Architecture\n\n**Hardware Stack:**\n- **Flight Controller MCU:** ATmega328p (Arduino-compatible 8-bit microcontroller)\n- **Sensors:** IMU (gyroscope + accelerometer), ToF distance sensor for altitude hold\n- **Communication:** Wireless protocol (likely nRF24L01 or similar 2.4GHz module)\n- **Actuators:** 4× brushless DC motors with ESCs (Electronic Speed Controllers)\n- **Power:** LiPo battery management system\n- **Remote:** Custom handheld controller with dual joysticks (throttle, yaw, pitch, roll)\n\n**Design Tools:**\n- **PCB Design:** KiCad (schematic capture, PCB layout, Gerber generation)\n- **Mechanical CAD:** Fusion 360 (frame design, motor mounts, enclosures)\n- **Firmware:** C/C++ (Arduino framework for ATmega328p)\n\n### Core Systems\n\n**1. Flight Controller PCB Design**\n\n**Custom Board Features:**\n- ATmega328p microcontroller with crystal oscillator circuit\n- IMU sensor interface (I2C/SPI communication)\n- ToF sensor integration for ground distance measurement\n- 4× PWM outputs for ESC control (motor speed regulation)\n- Wireless transceiver module connector\n- Power regulation (5V/3.3V rails from LiPo battery)\n- Programming header (ISP/UART for firmware upload)\n\n**KiCad Workflow:**\n```\nSchematic Design → Component Selection → PCB Layout → \nDesign Rule Check (DRC) → Gerber Export → Manufacturing\n```\n\n**Design Considerations:**\n- Compact form factor to minimize drone weight\n- Signal integrity for high-frequency IMU data\n- EMI shielding for wireless module\n- Thermal management for voltage regulators\n- Mounting holes aligned with Fusion 360 frame design\n\n**2. Sensor Fusion & Flight Stabilization**\n\n**IMU Integration:**\n- **Gyroscope:** Measures angular velocity (deg/s) for rate control\n- **Accelerometer:** Provides tilt angle via gravity vector\n- **Sensor Fusion:** Complementary filter combining gyro + accel data\n  - Gyro: Fast response but drifts over time\n  - Accel: Stable long-term but noisy short-term\n  - Filter: `angle = 0.98 * (angle + gyro*dt) + 0.02 * accel`\n\n**PID Control Loop:**\n```cpp\n// Stabilization for each axis (roll, pitch, yaw)\nfloat error = setpoint - currentAngle;\nfloat P = Kp * error;\nfloat I += Ki * error * dt;\nfloat D = Kd * (error - lastError) / dt;\nfloat output = P + I + D;\nmotorSpeed[i] = baseThrottle + output;  // Apply correction\n```\n\n**ToF Altitude Hold:**\n- Time-of-Flight sensor measures ground distance (cm precision)\n- Secondary PID loop maintains constant altitude\n- Fusion with IMU vertical acceleration for improved response\n\n**3. Wireless Communication Protocol**\n\n**Bidirectional Data Exchange:**\n- **Downlink (Remote → Drone):** Control inputs at ~50Hz update rate\n  - Throttle (0-255)\n  - Roll/Pitch/Yaw angles (-100 to +100)\n  - Mode flags (stabilize, altitude hold, emergency stop)\n- **Uplink (Drone → Remote):** Telemetry data\n  - Battery voltage\n  - Altitude reading\n  - Flight mode status\n\n**Packet Structure:**\n```cpp\nstruct ControlPacket {\n    uint8_t throttle;\n    int8_t roll, pitch, yaw;\n    uint8_t flags;  // Mode bits\n    uint16_t checksum;\n};\n```\n\n**4. Remote Controller Design**\n\n**Hardware:**\n- Dual analog joysticks (4 axes: throttle, yaw, pitch, roll)\n- ATmega328p for joystick ADC reading + wireless transmission\n- OLED display for telemetry feedback\n- Safety switches (arm/disarm, emergency cutoff)\n- Custom PCB designed in KiCad\n\n**Joystick Mapping:**\n- Left stick: Throttle (vertical), Yaw (horizontal)\n- Right stick: Pitch (vertical), Roll (horizontal)\n- Center deadzone implementation to avoid drift\n\n**5. Mechanical Design (Fusion 360)**\n\n**Frame Structure:**\n- Quadcopter X-configuration for stability\n- Motor mounts with vibration dampening\n- Central electronics bay for PCB + battery\n- Propeller guards (optional safety feature)\n- Modular design for easy component replacement\n\n**Material Selection:**\n- Frame: Carbon fiber or reinforced plastic (strength-to-weight ratio)\n- Motor mounts: 3D-printed TPU (vibration absorption)\n- Enclosures: ABS/PETG (impact resistance)\n\n**Weight Budget:**\n- Flight controller PCB: ~20g\n- Motors + ESCs: ~100g\n- Battery: ~150g (dependent on capacity)\n- Frame: ~80g\n- **Total:** <400g for agile flight characteristics\n\n### Flight Control Algorithm\n\n**Control Loop Architecture:**\n```cpp\nvoid loop() {\n    // 1. Read sensors (IMU, ToF) at 100-200Hz\n    readIMU(&gyro, &accel);\n    altitude = readToF();\n    \n    // 2. Sensor fusion\n    updateOrientation(gyro, accel);\n    \n    // 3. Receive remote commands\n    if (radio.available()) {\n        ControlPacket cmd = radio.read();\n    }\n    \n    // 4. PID stabilization\n    rollCorrection = pidRoll.compute(cmd.roll, currentRoll);\n    pitchCorrection = pidPitch.compute(cmd.pitch, currentPitch);\n    yawCorrection = pidYaw.compute(cmd.yaw, currentYaw);\n    \n    // 5. Altitude hold (if enabled)\n    if (altitudeHoldMode) {\n        throttleAdjust = pidAltitude.compute(targetAlt, altitude);\n    }\n    \n    // 6. Motor mixing (convert corrections to motor speeds)\n    motor1 = throttle + rollCorr - pitchCorr + yawCorr;\n    motor2 = throttle - rollCorr - pitchCorr - yawCorr;\n    motor3 = throttle - rollCorr + pitchCorr + yawCorr;\n    motor4 = throttle + rollCorr + pitchCorr - yawCorr;\n    \n    // 7. Safety limits & ESC output\n    writeMotors(constrain(motor1-4, 0, 255));\n}\n```\n\n## Challenges & Solutions\n\n| Challenge | Solution |\n|-----------|----------|\n| **PID tuning** for stable flight | Iterative testing with telemetry logging; Ziegler-Nichols method for initial parameters |\n| **Sensor noise** in IMU readings | Complementary filter + low-pass filtering; calibration routine at startup |\n| **Wireless latency** | Optimized packet size; 50Hz update rate balances responsiveness and reliability |\n| **Power distribution** on PCB | Separate analog/digital ground planes; thick copper traces for motor currents |\n| **Vibration interference** with IMU | Soft-mounted flight controller; vibration dampening in motor mounts |\n| **Weight constraints** | Miniaturized PCB design; single-layer carbon fiber frame; removed non-essential components |\n| **ESC calibration** | Automated throttle range calibration sequence in firmware |\n\n## Results / Impact\n\n**System Performance:**\n- ✅ **Stable hover:** Achieved hands-off hover with altitude hold\n- ✅ **Responsive control:** <50ms latency from joystick input to motor response\n- ✅ **Flight time:** 8-12 minutes (dependent on battery capacity)\n- ✅ **Range:** 100m+ wireless range (line-of-sight)\n- ✅ **Custom hardware:** 100% in-house PCB and frame design\n\n**Technical Achievements:**\n- Designed **complete PCB** from schematic to manufactured board (KiCad)\n- Implemented **sensor fusion algorithm** for attitude estimation\n- Developed **PID control system** with real-time tuning capability\n- Created **mechanical CAD model** with manufacturability constraints (Fusion 360)\n- Integrated **multi-sensor system** (IMU, ToF, wireless, ESCs) on single microcontroller\n\n**Engineering Skills Demonstrated:**\n- **Embedded Systems:** Firmware development, real-time control loops, interrupt handling\n- **Electronics Design:** Schematic capture, PCB layout, component selection, signal integrity\n- **Control Theory:** PID controllers, sensor fusion, motor mixing algorithms\n- **Mechanical Engineering:** CAD modeling, vibration analysis, weight optimization\n- **Systems Integration:** Coordinating electrical, mechanical, and software subsystems\n\n**Learning Outcomes:**\n- **Hardware/Software Co-Design:** Balancing firmware complexity with hardware constraints\n- **Flight Dynamics:** Practical application of control theory to unstable systems\n- **Design for Manufacturability:** PCB panelization, assembly considerations\n- **Debugging Embedded Systems:** Logic analyzer, oscilloscope, serial debugging\n\n## References\n\n- [Project Demo (LinkedIn)](https://www.linkedin.com/posts/leopold-rombaut_ececopter-embeddedsystems-dronetechnology-activity-7134805600864989185-h-t2)\n- **Design Tools:**\n  - [KiCad EDA](https://www.kicad.org/) - Open-source PCB design suite\n  - [Fusion 360](https://www.autodesk.com/products/fusion-360/) - CAD/CAM software\n- **Technical References:**\n  - Complementary Filter for IMU sensor fusion\n  - PID Control Theory for multirotor stabilization\n  - ATmega328p Datasheet (Microchip/Atmel)\n\n**Technologies:** ATmega328p, KiCad, Fusion 360, IMU (Gyroscope/Accelerometer), Time-of-Flight Sensor, PID Control, Sensor Fusion, Wireless Communication, PCB Design, Embedded C/C++, Motor Control (PWM/ESC), Flight Dynamics"
}