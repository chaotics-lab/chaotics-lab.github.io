{
  "title": "Power Consumption Measurement",
  "date": "2024-08-21",
  "titleColor": "#FFFFFF",
  "description": "Developed a measurement board to evaluate product battery life and optimize real-time signal processing to handle billions of data points.",
  "imageUrl": "/img/withings",
  "logoUrl": "/img/withings/logo.png",
  "themeColor": "#FFFFFF",
  "logoBackgroundColor": "#FFFFFF",
  "category": [
    
    "sp",
    "embedded-systems",
    "gui"
  ],
  "tags": [
    "C",
    "C++",
    "Python",
    "Kinetis K60",
    "Qt",
    "Ethernet"
  ],
  "type": "Internship",
  "AIUsed": "40",
  "id": "power-consumption-measurement-board",
  "markdown": "## What\nA real-time power consumption analysis tool for Withings' connected health devices, processing up to 13 billion data points per day from dual ADCs to identify firmware bugs and power inefficiencies. Enables engineers to validate battery life optimizations critical for products like ScanWatch (30-day battery vs Apple Watch's 18 hours).\n\n## How\nDesigned custom binary format using cumulative sum encoding, reducing average calculation from O(n) to O(1) for constant-time downsampling of billions of points. Implemented dual-ADC firmware with automatic switching at 360μA threshold, synchronizing ADS1247 (24-bit @ 2kHz) and LTC2378-18 (18-bit @ 62.5kHz) via pipe markers. Built Qt/PyQtGraph GUI achieving <10ms rendering of 1 billion points downsampled to screen pixels, replacing 46-class legacy system with streamlined 10-class MVC architecture.\n\n## Result\n10x GUI responsiveness (<100ms vs 10+ sec), unlimited acquisition length (20+ hours vs <2 hours), and 500 KB/s sustained streaming. Successfully deployed to production, catching critical firmware bugs like weight-on-scale 10× power consumption issue. Enabled Withings teams (embedded, industrialization, SQA) to accelerate development cycles and reduce warranty costs through pre-production power profiling.\n\n### AI Usage(40%)\nSpent 4 months deliberately learning Qt, Python, and embedded C firmware development. AI assisted with documentation generation, debugging edge cases, and test case creation, but core engineering decisions were manual (cumulative sum optimization algorithm, dual-ADC synchronization protocol, etc.). Project's simplicity resulted from extensive architecture head-scratching and multi-tasking simplification, not AI generation."
}