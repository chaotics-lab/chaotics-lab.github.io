{
  "title": "Power Consumption Measurement",
  "date": "2024-08-21",
  "titleColor": "#FFFFFF",
  "description": "Developed a measurement board to evaluate product battery life and optimize real-time signal processing to handle billions of data points.",
  "imageUrl": "/img/withings",
  "logoUrl": "/img/withings/logo.png",
  "themeColor": "#FFFFFF",
  "logoBackgroundColor": "#FFFFFF",
  "category": [
    "software",
    "sp",
    "embedded-systems",
    "gui"
  ],
  "tags": [
    "C",
    "C++",
    "Python",
    "Kinetis K60",
    "Qt",
    "Ethernet"
  ],
  "status": "completed",
  "id": "power-consumption-measurement-board",
  "markdown": "## Overview\n\nDeveloped a **real-time power consumption analysis tool** for Withings' connected health devices, enabling engineers to visualize and optimize battery life across product lines. The system captures up to **13 billion data points per day** from dual ADCs, processing high-resolution current measurements to identify firmware bugs and power inefficiencies that impact device autonomy — critical for products like smartwatches (3-4 weeks battery) and scales (2+ years without recharge).\n\n**Business Impact:** Withings differentiates itself through ultra-low power consumption (e.g., ScanWatch: 30 days vs Apple Watch: 18 hours). This tool enables teams to validate energy optimizations and detect regressions, directly supporting the company's core value proposition.\n\n## Technical Approach\n\n### System Architecture\n\n**Hardware Stack:**\n- **MCU:** Kinetis K60 (ARM Cortex-M4 @ 150MHz) with SPI bus management\n- **ADCs:** Dual-ADC architecture for multi-state power profiling:\n  - **ADS1247:** 24-bit resolution @ 2kHz (low-current sleep mode: 0.298μV step size)\n  - **LTC2378-18:** 18-bit resolution @ 62.5kHz (active mode transients: 19.07μV step size)\n- **Communication:** Ethernet PHY (proprietary protocol over TCP/IP)\n- **Design Rationale:** Automatic switching at 360μA threshold adapts to device state (active vs sleep)\n\n**Software Stack:**\n- **GUI Framework:** Qt (PySide6) with PyQtGraph for high-performance plotting\n- **Backend:** Python 3.8+ with NumPy for signal processing\n- **Firmware:** Embedded C on Kinetis K60 (SPI drivers, Ethernet stack)\n- **Data Storage:** Custom binary format with cumulative sum encoding\n\n### Challenge: Real-Time Visualization of Massive Datasets\n\n**Problem Statement:**\n- Data rate: 62,500 samples/sec × 8 bytes = **500 KB/s** continuous streaming\n- 24-hour acquisition = **43.2 GB** of raw data (13 billion points)\n- Legacy system: RAM bottleneck, outdated Python libraries (Tkinter/Matplotlib), <1 FPS rendering\n\n**Core Innovation: Cumulative Sum Storage Format**\n\nInstead of storing raw samples `[i₁, i₂, i₃, ...]`, store cumulative sums `[i₁, i₁+i₂, i₁+i₂+i₃, ...]`:\n\n```python\n# Traditional approach (slow)\ndef compute_average(data, start, end):\n    return sum(data[start:end]) / (end - start)  # O(n) iteration\n\n# Cumulative sum approach (O(1))\ndef compute_average_fast(cumsum, start, end):\n    return (cumsum[end] - cumsum[start-1]) / (end - start + 1)\n```\n\n**Mathematical Basis:**\n\n$$\\text{Average}(k_1, k_2) = \\frac{S(k_2) - S(k_1 - 1)}{k_2 - k_1 + 1}$$\n\nWhere $S(k)$ is the cumulative sum up to index $k$. This enables **constant-time downsampling** of millions of points.\n\n**Trade-off Analysis:**\n- ✅ **Performance:** Average calculation drops from O(n) → O(1)\n- ✅ **Downsampling:** Real-time zoom from 1 billion points → 1000 pixels in <10ms\n- ⚠️ **Storage:** 24-bit samples → 64-bit cumsum (2.67× size increase)\n- ⚠️ **Overflow risk:** 64-bit signed integer saturates after 101.8 days at max current (acceptable for typical 24h tests)\n\n### Core Systems\n\n**1. Dual-ADC Data Acquisition Pipeline**\n\n**Automatic Mode State Machine:**\n\n```c\n// Firmware logic (simplified)\nvoid ADC_AutoMode_ISR(void) {  // Called every 16μs\n    uint32_t ltc_value = SPI_Read_LTC2378();\n    \n    if (abs(ltc_value - MIDPOINT) > THRESHOLD_395uA) {\n        // High current: Use fast LTC reading\n        Ethernet_Send('L', ltc_value);  // 'L' = LTC marker\n    } else {\n        // Low current: Use precise ADS reading\n        Ethernet_Send('|');  // Pipe = 16μs sync marker\n        \n        if (++pipe_count >= 31) {  // 31 × 16μs ≈ 500μs\n            uint32_t ads_value = SPI_Read_ADS1247();\n            Ethernet_Send('A', ads_value);  // 'A' = ADS marker\n            pipe_count = 0;\n        }\n    }\n}\n```\n\n**Protocol Design:**\n- **Sync markers (`|`):** Maintain 62.5kHz timestamp grid during slow ADS reads\n- **ASCII commands:** `'L'` (0x4C), `'A'` (0x41), `'|'` (0x7C) for human-readable debugging\n- **Packet structure:** Variable-length Ethernet frames (max MTU) filled with raw ADC bytes\n\n**2. Data Normalization & Processing**\n\n**Resolution Unification:**\n\n```python\ndef normalize_ltc_to_24bit(ltc_18bit):\n    # Shift 18-bit LTC data to 24-bit scale\n    return ltc_18bit << 6  # Equivalent to × 2^6\n    # No precision loss: fills lower bits with zeros\n```\n\n**Frequency Normalization:**\n- ADS @ 2kHz → Upsample via hold: Repeat each sample 31× to match 62.5kHz LTC rate\n- Pipe markers (`|`) indicate when to duplicate previous ADS value\n- Result: Uniform 62.5kHz time grid for both ADCs\n\n**3. High-Performance GUI (Qt/PyQtGraph)**\n\n**Architecture:**\n\n```python\nclass MainWindow(QMainWindow):\n    def __init__(self):\n        # Dual-graph layout\n        self.top_plot = PyQtGraph.PlotWidget()  # Zoomed view\n        self.bottom_plot = PyQtGraph.PlotWidget()  # Full acquisition overview\n        \n        # Real-time update timer\n        self.timer = QTimer()\n        self.timer.timeout.connect(self.update_plot)\n        self.timer.start(50)  # 20 FPS refresh\n        \n    def update_plot(self):\n        # Downsample millions of points → screen pixels\n        visible_range = self.top_plot.viewRange()[0]\n        downsampled = self.downsample_cumsum(\n            start=int(visible_range[0]),\n            end=int(visible_range[1]),\n            num_pixels=self.top_plot.width()\n        )\n        self.top_plot.setData(downsampled)\n```\n\n**Downsampling Algorithm:**\n\n```python\ndef downsample_cumsum(self, start, end, num_pixels):\n    \"\"\"O(num_pixels) downsampling of arbitrary range\"\"\"\n    N = end - start\n    step = N / num_pixels\n    \n    result = np.zeros(num_pixels)\n    for i in range(num_pixels):\n        k1 = int(start + i * step)\n        k2 = int(start + (i + 1) * step) - 1\n        \n        # O(1) average calculation via cumsum\n        result[i] = (self.cumsum[k2] - self.cumsum[k1-1]) / (k2 - k1 + 1)\n    \n    return result\n```\n\n**Performance:**\n- 1 billion points → 1920 pixels (Full HD): **<10ms** on modern CPU\n- Eliminated Level-of-Detail (LOD) multi-file approach (old system: 5 files at different resolutions)\n\n**4. Ethernet Communication Layer**\n\n**Python Socket Handler:**\n\n```python\nclass EthernetInterface:\n    def __init__(self, port=\"192.168.1.100\"):\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.sock.connect((port, 8080))\n        \n    def send_command(self, cmd):\n        # API: calibrate_ads(), calibrate_ltc(), auto_mode(), etc.\n        self.sock.sendall(cmd.encode('ascii'))\n        \n    def receive_data(self):\n        \"\"\"Parse incoming Ethernet frames\"\"\"\n        buffer = bytearray()\n        while True:\n            chunk = self.sock.recv(1500)  # MTU size\n            buffer.extend(chunk)\n            \n            # Extract ADC readings based on markers\n            while len(buffer) >= 4:\n                marker = chr(buffer[0])\n                if marker == 'A':  # ADS reading\n                    value = struct.unpack('>I', buffer[1:4])[0]  # 24-bit big-endian\n                    yield ('ADS', value)\n                    buffer = buffer[4:]\n                elif marker == 'L':  # LTC reading\n                    value = struct.unpack('>I', buffer[1:4])[0]\n                    yield ('LTC', value << 6)  # Normalize to 24-bit\n                    buffer = buffer[4:]\n                elif marker == '|':  # Sync marker\n                    yield ('SYNC', None)\n                    buffer = buffer[1:]\n```\n\n**5. Firmware State Machine**\n\n**Calibration Sequence:**\n\n1. **Zero-current calibration:** Measure ADC offset with no load\n2. **Known-reference calibration:** Apply precision resistor (e.g., 1kΩ @ 3.3V = 3.3mA)\n3. **Gain coefficient calculation:** `gain = (measured - offset) / expected`\n4. **EEPROM storage:** Persist calibration for power cycles\n\n**State Diagram:**\n\n```\n[IDLE] --calibrate()--> [CALIBRATING] --done--> [READY]\n[READY] --start_acquisition()--> [STREAMING]\n[STREAMING] --stop()--> [IDLE]\n```\n\n### Binary File Format\n\n**Structure:**\n\n```\n[Header: 64 bytes]\n- Magic number: 0x57544853 (\"WTHS\" in ASCII)\n- Version: uint16\n- Sample rate: uint32 (62500 Hz)\n- ADC config: uint8 (auto/ads/ltc mode)\n- Timestamp: uint64 (Unix epoch)\n\n[Data: N × 8 bytes]\n- Cumulative sum: int64 (signed, little-endian)\n```\n\n**Benefits:**\n- Direct memory-mapping for O(1) random access\n- No parsing overhead (binary vs CSV/JSON)\n- Portable across platforms (explicit endianness)\n\n## Challenges & Solutions\n\n| Challenge | Solution |\n|-----------|----------|\n| **13 billion points/day** storage | Cumulative sum format + SSD storage (vs RAM); 43GB/day manageable |\n| **Real-time rendering** at 62.5kHz | O(1) downsampling via cumsum; PyQtGraph GPU acceleration |\n| **Dual-ADC synchronization** | Hardware interrupts + firmware state machine; pipe markers for timing |\n| **Qt learning curve** | Invested 2-3 weeks in framework mastery; leveraged extensive Qt documentation |\n| **Legacy codebase complexity** | Rewrote from scratch: 46 classes → 10 classes (78% reduction) |\n| **64-bit overflow** (101.8 days max) | Acceptable for typical <24h tests; documented limitation |\n| **Ethernet packet parsing** | Robust state machine handling fragmented/out-of-order packets |\n\n## Results / Impact\n\n**Performance Metrics:**\n- ✅ **10x GUI responsiveness:** <100ms plot updates vs 10+ sec in legacy system\n- ✅ **Unlimited acquisition length:** 20+ hour captures (previously <2 hours)\n- ✅ **Real-time streaming:** 500 KB/s sustained throughput\n- ✅ **Memory efficiency:** 43GB on SSD vs 8GB RAM limit (old system)\n- ✅ **Codebase simplification:** 78% class reduction (46 → 10)\n\n**Engineering Impact:**\n- **Embedded Software Team:** Validates firmware power states, detects polling bugs\n- **Industrialization Team:** Tests component integration, battery life estimates\n- **SQA Team:** Root-cause analysis for beta test failures\n\n**Example Bug Detection:**\n\nIn firmware testing, the tool revealed a **weight-on-scale bug** where a balance consumed 10× normal power while loaded (should enter sleep mode). Current trace showed continuous active state instead of expected periodic polling → Fixed in firmware update.\n\n**Business Value:**\n- Enables Withings' **core differentiation** (3-4 week watch battery vs 18h competitors)\n- Accelerates product development cycles (faster power profiling)\n- Reduces warranty costs (catches battery drain bugs pre-production)\n\n**Technical Achievements:**\n- Designed **custom binary format** optimized for billion-point datasets\n- Implemented **dual-ADC firmware** with automatic mode switching\n- Applied **algorithmic optimization** (cumsum) to eliminate performance bottleneck\n- Built **production-grade GUI** replacing 7-year-old legacy system\n\n**Learning Outcomes:**\n- **Embedded Systems:** Firmware development, SPI communication, ADC configuration\n- **Signal Processing:** Downsampling algorithms, data normalization, cumulative sum optimization\n- **GUI Development:** Qt framework, event-driven architecture, high-performance plotting\n- **Hardware Debugging:** Oscilloscope analysis, schematic reading, component datasheets\n- **System Architecture:** Refactored 46-class system → 10 classes (MVC pattern)\n\n## References\n\n- **Company:** [Withings](https://www.withings.com/) — French leader in connected health (€140M revenue, 400 employees)\n- **Products:** ScanWatch (30-day battery smartwatch), Body Smart (2-year battery scale)\n- **Technologies:**\n  - [Kinetis K60 MCU](https://www.nxp.com/products/processors-and-microcontrollers/arm-microcontrollers/general-purpose-mcus/k-series-cortex-m4/k6x-ethernet:KINETIS_K60_72_100_120_MHZ) (ARM Cortex-M4)\n  - [ADS1247 ADC](https://www.ti.com/product/ADS1247) (24-bit delta-sigma)\n  - [LTC2378-18 ADC](https://www.analog.com/en/products/ltc2378-18.html) (18-bit SAR)\n  - [Qt Framework](https://www.qt.io/) (cross-platform GUI)\n  - [PyQtGraph](http://www.pyqtgraph.org/) (scientific plotting)\n\n**Technologies:** Python, Qt (PySide6), PyQtGraph, C (Embedded), Kinetis K60 (ARM Cortex-M4), SPI, Ethernet, NumPy, Binary File I/O, Signal Processing, ADC (ADS1247, LTC2378), Power Profiling, Real-Time Systems, MVC Architecture"
}